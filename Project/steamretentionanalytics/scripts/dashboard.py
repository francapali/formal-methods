import streamlit as st
import pandas as pd
import plotly.express as px
import os
from PIL import Image
from pathlib import Path

st.set_page_config(
    page_title="Steam Process Mining Dashboard",
    page_icon="ðŸŽ®",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS styling
st.markdown("""
    <style>
    .main {
        background-color: #f5f5f5;
    }
    
    [data-testid="stMetric"] {
        background-color: #ffffff;
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        border: 1px solid #e0e0e0;
    }

    [data-testid="stMetricValue"] {
        color: #1b2838 !important;
    }

    [data-testid="stMetricLabel"] {
        color: #555555 !important;
    }

    [data-testid="stMetricDelta"] {
        color: #1b2838 !important;
        background-color: rgba(0,0,0,0.05);
        padding: 2px 8px;
        border-radius: 20px;
        font-weight: bold;
    }
    
    [data-testid="stMetricDelta"] > div {
        color: inherit !important;
    }

    h1, h2, h3 {
        color: #1b2838;
    }
    </style>
    """, unsafe_allow_html=True)


@st.cache_data
def load_data():
    base_dir = Path(__file__).resolve().parent.parent
    file_path = base_dir / "output" / "preprocessed_data" / "steam_enriched_log.csv"
    if os.path.exists(file_path):
        df = pd.read_csv(file_path)
        if 'timestamp' in df.columns:
            df['timestamp'] = pd.to_datetime(df['timestamp'])
        return df
    return None


def load_image(filename):
    base_dir = Path(__file__).resolve().parent.parent
    path = base_dir / "output" / "petri_nets" / filename
    print(path)
    if os.path.exists(path):
        return Image.open(path)
    return None


with st.sidebar:
    st.image("https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Steam_icon_logo.svg/512px-Steam_icon_logo.svg.png", width=100)
    st.title("Navigation")
    page = st.radio("Go to:", [
        "Project Overview",
        "Process Models",
        "Business KPIs",
        "AI Analyst (Chatbot)"
    ])

    st.markdown("---")
    st.caption("Developed by:")
    st.caption("ðŸ‘¤ Yuri Tateo")
    st.caption("ðŸ‘¤ Francesca Palumbo")
    st.caption("ðŸ“… A.Y. 2025/2026")

if page == "Project Overview":
    st.title("ðŸŽ® Steam Retention Analytics")
    st.subheader("Process Mining Applied to E-Commerce Behavior")

    col1, col2 = st.columns([2, 1])

    with col1:
        st.markdown("""
        ### ðŸŽ¯ Objective
        This project analyzes the "Customer Journey" of Steam users, focusing on the gap between *Purchasing* and *Playing*.
        
        ### ðŸ” Key Questions
        * *Retention:* Do users play what they buy?
        * *Churn:* When do users abandon a game?
        * *Value:* What leads to a DLC purchase?
        
        ### ðŸ›  Tech Stack
        * *Algorithm:* Inductive Miner (PM4Py)
        * *Analysis:* LLM-based Reasoning
        * *Visualization:* Streamlit & Plotly
        """)

    with col2:
        st.info("*Dataset Info*")
        df = load_data()
        if df is not None:
            st.metric("Total Events", len(df))
            st.metric("Total Cases (Users)", df['case_id'].nunique())
            st.metric("Unique Games", df['game'].nunique())
        else:
            st.warning("Dataset not found. Please ensure 'steam_event_log.csv' is in the folder.")

elif page == "Process Models":
    st.title("ðŸ•¸ï¸ Process Discovery Models")
    st.write("Comparison of different mining algorithms applied to the Event Log.")

    model_type = st.selectbox("Select Algorithm:", ["Alpha Miner", "Heuristic Miner", "Inductive Miner"], index=2)

    col_img, col_metrics = st.columns([3, 1])

    metrics = {
        "Alpha Miner": {"fit": 0.132, "prec": 0.340, "img": "alpha_steam.png",
                        "verdict": "âŒ *Discarded.* The model is disconnected (Spaghetti structure) and fails to capture loops. Fitness is unacceptably low."},
        "Heuristic Miner": {"fit": 0.964, "prec": 0.519, "img": "heuristic_steam.png",
                            "verdict": "âš ï¸ *Runner Up.* Good balance, but lacks mathematical soundness guarantees."},
        "Inductive Miner": {"fit": 1.000, "prec": 0.334, "img": "inductive_steam.png",
                            "verdict": "âœ… *Selected Model.* Guarantees a sound process tree. Perfect fitness ensures all user behaviors (including the Long Tail) are represented."}
    }

    current = metrics[model_type]

    with col_img:
        img = load_image(current["img"])
        if img:
            st.image(img, caption=f"Petri Net generated by {model_type}", use_container_width=True)
        else:
            st.error(f"Image {current['img']} not found in 'output_images/' folder.")

    with col_metrics:
        st.subheader("Model Evaluation")

        fit_color = "normal" if current['fit'] > 0.8 else "off"
        st.metric("Fitness", f"{current['fit']:.3f}", delta="Excellent" if current['fit'] > 0.9 else "-Poor", delta_color=fit_color)

        prec_delta = "Acceptable" if current['prec'] > 0.5 else "Low (Generalization)"
        st.metric("Precision", f"{current['prec']:.3f}", delta=prec_delta, delta_color="off")

        st.markdown("---")
        st.markdown("### Technical Verdict")
        st.markdown(current['verdict'])

elif page == "Business KPIs":
    st.title("ðŸ“Š Business Insights & KPI")

    df = load_data()

    if df is not None:
        case_summary = df.groupby('case_id')['activity'].apply(list).reset_index()
        case_summary['variant_type'] = case_summary['activity'].apply(
            lambda x: 'Active Player (Played)' if 'Start Playing' in x else 'Backlog (Purchase Only)'
        )

        purchase_times = df[df['activity'] == 'Purchase Game'][['case_id', 'timestamp']].rename(columns={'timestamp': 't_buy'})
        play_times = df[df['activity'] == 'Start Playing'][['case_id', 'timestamp']].rename(columns={'timestamp': 't_play'})

        time_analysis = pd.merge(purchase_times, play_times, on='case_id')
        time_analysis['hours_delay'] = (time_analysis['t_play'] - time_analysis['t_buy']).dt.total_seconds() / 3600
        time_analysis = time_analysis[time_analysis['hours_delay'] > 0]
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("1. The 'Backlog' Problem")
            fig_pie = px.pie(case_summary, names='variant_type', title='User Segments: Played vs. Never Played',
                             color_discrete_sequence=['#66c0f4', '#1b2838'])
            st.plotly_chart(fig_pie, use_container_width=True)
            st.caption("Insight: A significant portion of revenue comes from users who never launch the game.")

        with col2:
            st.subheader("2. Time-to-Engagement")
            fig_hist = px.histogram(time_analysis, x='hours_delay', nbins=20,
                                    title='Hours between Purchase and First Play',
                                    labels={'hours_delay': 'Hours'},
                                    color_discrete_sequence=['#c7d5e0'])
            fig_hist.add_vline(x=time_analysis['hours_delay'].mean(), line_dash="dash", line_color="red", annotation_text="Avg Delay")
            st.plotly_chart(fig_hist, use_container_width=True)
            st.caption(f"Avg Delay: {time_analysis['hours_delay'].mean():.1f} hours. Users often wait before playing.")

    else:
        st.error("Data not available. Please run the data generation script first.")


elif page == "AI Analyst (Chatbot)":
    st.title("ðŸ¤– AI Process Analyst")
    st.markdown("""
    Ask questions about the mining results. The AI Agent uses the *Inductive Miner* logic to reason about the process.
    (Try asking about: 'churn', 'backlog', 'strategy', or 'anomalies')
    """)

    if "messages" not in st.session_state:
        st.session_state.messages = []
        st.session_state.messages.append({"role": "assistant", "content": "Hello! I have analyzed 2,100 Steam user cases. Ask me about retention or bottlenecks!"})
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])

    if prompt := st.chat_input("Ask a question about the process..."):
        st.session_state.messages.append({"role": "user", "content": prompt})
        with st.chat_message("user"):
            st.markdown(prompt)
        prompt_lower = prompt.lower()
        response = ""

        if "churn" in prompt_lower or "abandon" in prompt_lower or "refund" in prompt_lower:
            response = """
            *âš ï¸ Churn Analysis Detected*
            
            My analysis of the Inductive Petri Net reveals a critical "Refund Risk" path.
            - *Data:* 310 users (approx 15%) follow the path Purchase -> Play -> Abandon.
            - *Timing:* This usually happens within the first *2 hours* (Steam Refund Window).
            - *Root Cause:* Likely a mismatch between marketing expectations and actual gameplay, or technical issues at launch.
            """

        elif "backlog" in prompt_lower or "skip" in prompt_lower or "never play" in prompt_lower:
            response = """
            *ðŸ“š The Backlog Phenomenon*
            
            Yes, I identified a significant anomaly: the *"Purchase-Only" variant*.
            - *Observation:* A visual arc in the model skips the Start Playing node entirely.
            - *Business Impact:* Pure profit in the short term (revenue without server costs), but these are "Dormant Users" with low Lifetime Value.
            - *Hypothesis:* Impulse buying during Seasonal Sales.
            """

        elif "strategy" in prompt_lower or "optimize" in prompt_lower or "dlc" in prompt_lower or "monetization":
            response = """
            *ðŸš€ Optimization Strategy: 'The Golden Hour'*
            
            To increase DLC sales, we shouldn't wait for users to finish the game.
            - *Insight:* Engagement peaks between 20-50 hours.
            - *Proposal:* Trigger a targeted "Season Pass" discount notification exactly when a user crosses the *20-hour playtime mark*.
            - *Goal:* Reduce the throughput time between Start Playing and Purchase DLC.
            """

        else:
            response = """
            I am focused on the Steam Process Mining analysis. 
            Could you please ask specifically about *churn, **backlog patterns, or **monetization strategies*?
            """

        st.session_state.messages.append({"role": "assistant", "content": response})
        with st.chat_message("assistant"):
            st.markdown(response)
